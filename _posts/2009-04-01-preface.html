---
layout: post
title: Preface to Domain-Driven Design (pages xix-xxvi)
date: 2009-04-01 01:43:32.000000000 -06:00
type: post
published: true
status: publish
categories: []
tags: []
meta:
  _gcid: '64'
  _edit_last: '1'
  _wp_page_template: default
  _bitly_trim: http://dddcommunity.org/?p=55
author:
  login: Vladimir Gitlevich
  email: webmaster@domaindrivendesign.org
  display_name: Vladimir Gitlevich
  first_name: Vladimir Gitlevich
  last_name: ''
---

<p>by Eric Evans</p>
<p>Leading software designers have recognized domain modeling and design as critical topics for at least twenty years, yet surprisingly little has been written about what needs to be done or how to do it. Although it has never been formulated clearly, a philosophy has emerged as an undercurrent in the object community, a philosophy I call <em>domain-driven design</em>.</p>
<p class="MsoBodyText">I have spent the past decade developing complex systems in several business and technical domains. In my work, I have tried best practices in design and development process as they have emerged from the leaders in object-oriented development. Some of my projects were very successful; a few failed. A feature common to the successes was a rich domain model that evolved through iterations of design and became part of the fabric of the project.</p>
<p class="MsoBodyText">This book provides a framework for making design decisions and a technical vocabulary for discussing domain design. It is a synthesis of widely accepted best practices along with my own insights and experiences. Software development teams facing complex domains can use this framework to approach domain-driven design systematically.</p>
<p class="MsoBodyText">&nbsp;</p>
<h3 class="BHead">Contrasting Three Projects</h3>
<p class="BodyTextNoIndent">Three projects stand out in my memory as vivid examples of how dramatically domain-design practice can affect development results. Although all three projects delivered useful software, only one achieved its ambitious objectives and produced complex software that continued to evolve to meet the ongoing needs of the organization.</p>
<p class="MsoBodyText">I watched one project get out of the gate fast, by delivering a useful, simple Web-based trading system. Developers were flying by the seat of their pants, but this didn't hinder them because simple software can be written with little attention to design. As a result of this initial success, expectations for future development were sky-high. That is when I was asked to work on the second version. When I took a close look, I saw that they lacked a domain model, or even a common language on the project, and were saddled with an unstructured design. The project leaders did not agree with my assessment, and I declined the job. A year later, the team found itself bogged down and unable to deliver a second version. Although their use of technology was not exemplary, it was the business logic that overcame them. Their first release had ossified prematurely into a high-maintenance legacy.</p>
<p class="MsoBodyText">Lifting this ceiling on complexity calls for a more serious approach to the design of domain logic. Early in my career, I was fortunate to end up on a project that did emphasize domain design. This project, in a domain at least as complex as the first one, also started with a modest initial success, delivering a simple application for institutional traders. But in this case, the initial delivery was followed up with successive accelerations of development. Each iteration opened exciting new options for integrating and elaborating the functionality of the previous release. The team was able to respond to the needs of the traders with flexibility and expanding capability. This upward trajectory was directly attributable to an incisive domain model, repeatedly refined and expressed in code. As the team gained new insight into the domain, the model deepened. The quality of communication improved not only among developers but also between developers and domain experts, and the design-far from imposing an ever-heavier maintenance burden-became easier to modify and extend.</p>
<p class="MsoBodyText">Unfortunately, projects don't arrive at such a virtuous cycle just by taking models seriously. One project from my past started with lofty aspirations to build a global enterprise system based on a domain model, but after years of disappointment, it lowered its sights and settled into conventionality. The team had good tools and a good understanding of the business, and it gave careful attention to modeling. But a poorly chosen separation of developer roles disconnected modeling from implementation, so that the design did not reflect the deep analysis that was going on. In any case, the design of detailed business objects was not rigorous enough to support combining them in elaborate applications. Repeated iteration produced no improvement in the code, due to uneven skill levels among developers, who had no awareness of the informal body of style and technique for creating model-based objects that also function as practical, running software. As months rolled by, development work became mired in complexity and the team lost its cohesive vision of the system. After years of effort, the project did produce modest, useful software, but the team had given up its early ambitions along with the model focus.</p>
<p class="MsoBodyText">&nbsp;</p>
<h3 class="BHead">The Challenge of Complexity</h3>
<p class="BodyTextNoIndent">Many things can put a project off course: bureaucracy, unclear objectives, and lack of resources, to name a few. But it is the approach to design that largely determines how complex software can become. When complexity gets out of hand, developers can no longer understand the software well enough to change or extend it easily and safely. On the other hand, a good design can create opportunities to exploit those complex features.</p>
<p class="MsoBodyText">Some design factors are technological. A great deal of effort has gone into the design of networks, databases, and other technical dimensions of software. Many books have been written about how to solve these problems. Legions of developers have cultivated their skills and followed each technical advancement.</p>
<p class="MsoBodyText">Yet the most significant complexity of many applications is not technical. It is in the domain itself, the activity or business of the user. When this domain complexity is not handled in the design, it won't matter that the infrastructural technology is well conceived. A successful design must systematically deal with this central aspect of the software.</p>
<p class="MsoBodyText">The premise of this book is twofold:</p>
<p><strong>1. For most software projects, the primary focus should be on the domain and domain logic.</strong></p>
<p><strong> 2. Complex domain designs should be based on a model.</strong></p>
<p class="MsoBodyText">Domain-driven design is both a way of thinking and a set of priorities, aimed at accelerating software projects that have to deal with complicated domains. To accomplish that goal, this book presents an extensive set of design practices, techniques, and principles.</p>
<p class="MsoBodyText">&nbsp;</p>
<h3 class="BHead">Design Versus Development Process</h3>
<p class="BodyTextNoIndent">Design books. Process books. They seldom even reference each other. Each topic is complex in its own right. This is a design book, but I believe that design and process are inextricable. Design concepts must be implemented successfully or else they will dry up into academic discussion.</p>
<p class="MsoBodyText">When people learn design techniques, they feel excited by the possibilities. Then the messy realities of a real project descend on them. They can't fit the new design ideas with the technology they must use. Or they don't know when to let go of a particular design aspect in the interest of time and when to dig in their heels and find a clean solution. Developers can and do talk with each other abstractly about the application of design principles, but it is more natural to talk about how real things get done. So, although this is a design book, I'm going to barge right across that artificial boundary into process when I need to. This will help put design principles in context.</p>
<p class="MsoBodyText">This book is not tied to a particular methodology, but it is oriented toward the new family of "Agile development processes." Specifically, it assumes that a couple of practices are in place on the project. These two practices are prerequisites for applying the approach in this book.</p>
<p class="NumberedList"><strong>1. Development is iterative.</strong> Iterative development has been advocated and practiced for decades, and it is a cornerstone of Agile development methods. There are many good discussions in the literature of Agile development and Extreme Programming (or XP), among them, <em>Surviving Object-Oriented Projects</em><span class="CitationReference"> (Cockburn 1998) </span>and <em>Extreme Programming Explained</em><span class="CitationReference"> (Beck 1999)</span>. </p>
<p class="NumberedList"> <strong>2. Developers and domain experts have a close relationship.</strong> Domain-driven design crunches a huge amount of knowledge into a model that reflects deep insight into the domain and a focus on the key concepts. This is a collaboration between those who know the domain and those who know how to build software. Because development is iterative, this collaboration must continue throughout the project's life.</p>
<p class="MsoBodyText">Extreme Programming, conceived by Kent Beck, Ward Cunningham, and others (see <em>Extreme Programming Explained</em><span class="CitationReference"> [Beck 2000])</span>, is the most prominent of the Agile processes and the one I have worked with most. Throughout this book, to make explanations concrete, I will use XP as the basis for discussion of the interaction of design and process. The principles illustrated are easily adapted to other Agile processes.</p>
<p class="SpaceBreak"><strong><o:p>&nbsp;</o:p></strong></p>
<p class="BodyTextNoIndent">In recent years there has been a rebellion against elaborate development methodologies that burden projects with useless, static documents and obsessive upfront planning and design. Instead, the Agile processes, such as XP, emphasize the ability to cope with change and uncertainty. </p>
<p class="MsoBodyText">Extreme Programming recognizes the importance of design decisions, but it strongly resists upfront design. Instead, it puts an admirable effort into communication and improving the project's ability to change course rapidly. With that ability to react, developers can use the "simplest thing that could work" at any stage of a project and then continuously refactor, making many small design improvements, ultimately arriving at a design that fits the customer's true needs.</p>
<p class="MsoBodyText">This minimalism has been a much-needed antidote to some of the excesses of design enthusiasts. Projects have been bogged down by cumbersome documents that provided little value. They have suffered from "analysis paralysis," with team members so afraid of an imperfect design that they made no progress at all. Something had to change.</p>
<p class="MsoBodyText">Unfortunately, some of these process ideas can be misinterpreted. Each person has a different definition of "simplest." Continuous refactoring is a series of small redesigns; developers without solid design principles will produce a code base that is hard to understand or change-the opposite of agility. And although fear of unanticipated requirements often leads to overengineering, the attempt to avoid overengineering can develop into another fear: a fear of doing any deep design thinking at all. </p>
<p class="MsoBodyText">In fact, XP works best for developers with a sharp design sense. The XP process assumes that you can improve a design by refactoring, and that you will do this often and rapidly. But past design choices make refactoring itself either easier or harder. The XP process attempts to increase team communication, but model and design choices clarify or confuse communication.</p>
<p class="MsoBodyText">This book intertwines design and development practice and illustrates how domain-driven design and Agile development reinforce each other. A sophisticated approach to domain modeling within the context of an Agile development process will accelerate development. The interrelationship of process with domain development makes this approach more practical than any treatment of "pure" design in a vacuum.</p>
<p class="MsoBodyText">&nbsp;</p>
<h3 class="BHead">The Structure of This Book</h3>
<p class="BodyTextNoIndent">The book is divided into four major sections:</p>
<p class="UnnumberedList"><em>Part I: Putting the Domain Model to Work</em> presents the basic goals of domain-driven development; these goals motivate the practices in later sections. Because there are so many approaches to software development <span>Part I</span> defines terms and gives an overview of the implications of using the domain model to drive communication and design.</p>
<p class="UnnumberedList"><em>Part II: The Building Blocks of Model-Driven Design</em> condenses a core of best practices in object-oriented domain modeling into a set of basic building blocks. This section focuses on bridging the gap between models and practical, running software. Sharing these standard patterns brings order to the design. Team members more easily understand each other's work. Using standard patterns also contributes terminology to a common language, which all team members can use to discuss model and design decisions.<br />
 <span> </span>But the main point of this section is to focus on the kinds of decisions that keep the model and implementation aligned with each other, each reinforcing the other's effectiveness. This alignment requires attention to the detail of individual elements. Careful crafting at this small scale gives developers a steady foundation from which to apply the modeling approaches of Parts III and IV.</p>
<p class="UnnumberedList"><em>Part III: Refactoring Toward Deeper Insight</em> goes beyond the building blocks to the challenge of assembling them into practical models that provide the payoff. Rather than jumping directly into esoteric design principles, this section emphasizes the discovery process. Valuable models do not emerge immediately; they require a deep understanding of the domain. That understanding comes from diving in, implementing an initial design based on a probably nave model, and then transforming it again and again. Each time the team gains insight, the model is transformed to reveal that richer knowledge, and the code is refactored to reflect the deeper model and make its potential available to the application. Then, once in a while, this onion peeling leads to an opportunity to break through to a much deeper model, attended by a rush of profound design changes.<br />
 <span> </span>Exploration is inherently open-ended, but it does not have to be random. <span>Part III</span> delves into modeling principles that can guide choices along the way, and techniques that help direct the search.</p>
<p class="UnnumberedList"><em>Part IV: Strategic Design</em> deals with situations that arise in complex systems, larger organizations, and interactions with external systems and legacy systems. This section explores a triad of principles that apply to the system as a whole: context, distillation, and large-scale structure. Strategic design decisions are made by teams, or even among teams. Strategic design enables the goals of <span>Part I</span> to be realized on a larger scale, for a big system or an application that fits into a sprawling, enterprise-wide network.</p>
<p class="MsoBodyText">Throughout the book, discussions are illustrated not with oversimplified, "toy" problems, but with realistic examples drawn from actual projects.</p>
<p class="MsoBodyText">Much of the book is written as a set of "patterns." Readers should be able to understand the material without concern about this device, but those who are interested in the style and format of the patterns are encouraged to read the appendix.</p>
<p class="SpaceBreak"><o:p>&nbsp;</o:p></p>
<p class="BodyTextNoIndent">Supplemental materials can be found at <a href="http://domaindrivendesign.org">http://domaindrivendesign.org</a>, including additional example code and community discussion.</p>
<h3 class="BodyTextNoIndent"><o:p>&nbsp;</o:p></h3>
<h3 class="BodyTextNoIndent">Who Should Read This Book</h3>
<p class="BodyTextNoIndent">This book is written primarily for developers of object-oriented software. Most members of a software project team can benefit from some parts of the book. It will make the most sense to people who are currently involved with a project, trying to do some of these things as they go through, and to people who already have deep experience with such projects.</p>
<p class="MsoBodyText">Some knowledge of object-oriented modeling is necessary to benefit from this book. The examples include UML diagrams and Java code, so the ability to read those languages at a basic level is important, but it is unnecessary to have mastered the details of either. Knowledge of Extreme Programming will add perspective to the discussions of development process, but the material should be understandable to those without background knowledge.</p>
<p class="MsoBodyText">For intermediate software developers-readers who already know something of object-oriented design and may have read one or two software design books-this book will fill in gaps and provide perspective on how object modeling fits into real life on a software project. The book will help intermediate developers learn to apply sophisticated modeling and design skills to practical problems.</p>
<p class="MsoBodyText">Advanced or expert software developers will be interested in the book's comprehensive framework for dealing with the domain. This systematic approach to design will help technical leaders guide their teams down this path. Also, the coherent terminology used throughout the book will help advanced developers communicate with their peers.</p>
<p class="MsoBodyText">This book is a narrative, and it can be read from beginning to end, or from the beginning of any chapter. Readers of various backgrounds may wish to take different paths through the book, but I do recommend that all readers start with the introduction to Part I, as well as Chapter 1. Beyond that, the core is probably Chapters 2, 3, 9, and 14. A skimmer who already has some grasp of a topic should be able to pick up the main points by reading headings and bold text. A very advanced reader may want to skim Parts I and II and will probably be most interested in Parts III and IV.</p>
<p class="MsoBodyText">In addition to this core readership, analysts and relatively technical project managers will also benefit from reading the book. Analysts can draw on the connection between model and design to make more effective contributions in the context of an Agile project. Analysts may also use some of the principles of strategic design to better focus and organize their work.</p>
<p class="MsoBodyText">Project managers should be interested in the emphasis on making a team more effective and more focused on designing software meaningful to business experts and users. And because strategic design decisions are interrelated with team organization and work styles, these design decisions necessarily involve the leadership of the project and have a major impact on the project's trajectory.</p>
<p class="MsoBodyText">&nbsp;</p>
<h3 class="BHead">A Domain-Driven Team</h3>
<p class="BodyTextNoIndent">Although an individual developer who understands domain-driven design will gain valuable design techniques and perspective, the biggest gains come when a team joins together to apply a domain-driven design approach and to move the domain model to the project's center of discourse. By doing so, the team members will share a language that enriches their communication and keeps it connected to the software. They will produce a lucid implementation in step with a model, giving leverage to application development. They will share a map of how the design work of different teams relates, and they will systematically focus attention on the features that are most distinctive and valuable to the organization.</p>
<p class="MsoBodyText">Domain-driven design is a difficult technical challenge that can pay off big, opening opportunities just when most software projects begin to ossify into legacy.</p>
<p></p>
